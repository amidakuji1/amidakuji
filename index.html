<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>あみだくじジェネレーター</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    canvas { width: 100%; height: 400px; border: 1px solid #ddd; background: #fff; }
    .fade-in { animation: fadeIn 0.4s ease-in-out; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
  </style>
</head>
<body class="bg-gray-50 min-h-screen flex flex-col items-center p-4">
  <div id="admin" class="w-full max-w-xl bg-white shadow-lg rounded-2xl p-6 fade-in">
    <h1 class="text-2xl font-bold mb-4 text-center">あみだくじ設定</h1>

    <label class="block font-semibold mb-1">参加者（1行ずつ）</label>
    <textarea id="players" class="w-full border rounded p-2 mb-4" rows="3">小泉
久郷
吉田</textarea>

    <label class="block font-semibold mb-1">結果（1行ずつ）</label>
    <textarea id="results" class="w-full border rounded p-2 mb-4" rows="3">27
29
休み</textarea>

    <label class="block font-semibold mb-1">固定設定（例: 小泉,休み）</label>
    <textarea id="fixed" class="w-full border rounded p-2 mb-4" rows="2">小泉,休み</textarea>

    <button id="generate" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded">URLを生成</button>
    <div id="urlArea" class="mt-4 hidden">
      <p class="font-semibold mb-1">共有用URL:</p>
      <input id="shareUrl" readonly class="w-full border rounded p-2 text-sm" />
    </div>
  </div>

  <div id="play" class="hidden w-full max-w-3xl bg-white shadow-lg rounded-2xl p-6 mt-4 fade-in">
    <h2 class="text-xl font-bold mb-2 text-center">あみだくじ</h2>
    <canvas id="amidakuji" width="600" height="400"></canvas>
    <div id="playerButtons" class="flex justify-center space-x-2 mt-4"></div>
    <div id="resultDisplay" class="text-center mt-4 text-lg font-semibold"></div>
  </div>

  <script>
    const adminDiv = document.getElementById('admin');
    const playDiv = document.getElementById('play');
    const canvas = document.getElementById('amidakuji');
    const ctx = canvas.getContext('2d');

    // 安全なBase64(JSON)エンコード／デコード（日本語対応）
    function safeBase64Encode(obj) {
      const json = JSON.stringify(obj);
      const encoded = encodeURIComponent(json).replace(/%([0-9A-F]{2})/g, (_, p1) =>
        String.fromCharCode(parseInt(p1, 16))
      );
      return btoa(encoded);
    }
    function safeBase64Decode(str) {
      const decoded = atob(str);
      const percentEncoded = decoded.split('')
        .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
        .join('');
      return JSON.parse(decodeURIComponent(percentEncoded));
    }

    // グローバルなアニメーショントークン（新しい再生が来たら古い再生を止める）
    let globalAnimToken = 0;

    function initAdminMode() {
      adminDiv.classList.remove('hidden');
      playDiv.classList.add('hidden');

      document.getElementById('generate').onclick = () => {
        try {
          const players = document.getElementById('players').value.trim().split(/\n|,/).map(v => v.trim()).filter(v => v);
          const results = document.getElementById('results').value.trim().split(/\n|,/).map(v => v.trim()).filter(v => v);
          const fixedPairs = document.getElementById('fixed').value.trim().split(/\n|,/).map(v => v.trim()).filter(v => v);
          const fixed = {};
          for (let i = 0; i < fixedPairs.length; i += 2) {
            if (fixedPairs[i] && fixedPairs[i + 1]) fixed[fixedPairs[i]] = fixedPairs[i + 1];
          }

          const config = { players, results, fixed };
          const encoded = encodeURIComponent(safeBase64Encode(config));
          // ここで baseURL をあなたの GitHub Pages に合わせる
          const baseURL = "https://amidakuji1.github.io/amidakuji/";
          const url = `${baseURL}#data=${encoded}`;

          document.getElementById('shareUrl').value = url;
          document.getElementById('urlArea').classList.remove('hidden');
          // 選択したら自動で選択/コピーを試みる（ユーザー許可次第）
          try { document.getElementById('shareUrl').select(); document.execCommand('copy'); } catch(e){/*ignore*/}

        } catch (e) {
          alert("URL生成中にエラーが発生しました: " + e.message);
        }
      };
    }

    function startAmidakuji(config) {
      adminDiv.classList.add('hidden');
      playDiv.classList.remove('hidden');

      const { players, results, fixed } = config;
      const columns = Math.max(1, players.length);

      // compute spacing based on canvas pixel size
      const spacingX = canvas.width / (columns + 1);
      const spacingY = canvas.height / 15;
      const lines = Array.from({length: columns}, ()=>[]);

      // random horizontal rungs
      for (let y = 1; y < 14; y++) {
        if (Math.random() < 0.5 && columns > 1) {
          const pos = Math.floor(Math.random() * (columns - 1));
          lines[pos].push(y);
        }
      }

      ctx.lineWidth = 2;
      ctx.strokeStyle = '#333';

      function drawLines() {
        // draw base (clears previous red path as well)
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // verticals
        for (let i = 0; i < columns; i++) {
          const x = spacingX * (i + 1);
          ctx.beginPath();
          ctx.moveTo(x, spacingY);
          ctx.lineTo(x, spacingY * 14);
          ctx.stroke();
        }
        // horizontals
        for (let i = 0; i < lines.length; i++) {
          for (const y of lines[i]) {
            ctx.beginPath();
            ctx.moveTo(spacingX * (i + 1), spacingY * y);
            ctx.lineTo(spacingX * (i + 2), spacingY * y);
            ctx.stroke();
          }
        }
      }

      drawLines();

      // mapping: apply fixed then random
      const mapping = {};
      const shuffled = [...results];
      for (const name in fixed) {
        mapping[name] = fixed[name];
        const idx = shuffled.indexOf(fixed[name]);
        if (idx !== -1) shuffled.splice(idx, 1);
      }
      const remainingPlayers = players.filter(p => !fixed[p]);
      for (const p of remainingPlayers) {
        mapping[p] = shuffled.pop();
      }

      // build buttons
      const btnContainer = document.getElementById('playerButtons');
      btnContainer.innerHTML = '';
      const resultDisplay = document.getElementById('resultDisplay');

      players.forEach(name => {
        const btn = document.createElement('button');
        btn.textContent = name;
        btn.className = 'bg-blue-500 hover:bg-blue-600 text-white py-1 px-3 rounded';
        btn.onclick = () => animatePath(name);
        btnContainer.appendChild(btn);
      });

      // animate path following the exact black lines
      function animatePath(name) {
        // increment token to cancel any running animation
        globalAnimToken++;
        const myToken = globalAnimToken;

        // reset base drawing (clears previous red)
        drawLines();
        // clear result text immediately
        resultDisplay.innerHTML = '';

        // compute path points precisely (x,y) following rungs
        let col = players.indexOf(name);
        let x = spacingX * (col + 1);
        let y = spacingY;
        const path = [[x, y]];

        for (let i = 1; i <= 14; i++) {
          y = spacingY * i;
          // if there's a rung to the right at this row for current col
          if (lines[col] && lines[col].includes(i)) {
            // go horizontal to right
            path.push([x, y]);
            x += spacingX;
            path.push([x, y]);
            col = col + 1;
          }
          // else if there's a rung to the left (in previous column)
          else if (col > 0 && lines[col - 1] && lines[col - 1].includes(i)) {
            path.push([x, y]);
            x -= spacingX;
            path.push([x, y]);
            col = col - 1;
          } else {
            path.push([x, y]);
          }
        }

        // draw animation step-by-step; check token each step to abort if changed
        let idx = 0;
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 3;

        function step() {
          if (myToken !== globalAnimToken) {
            // a new animation started — abort current animation cleanly
            return;
          }
          if (idx >= path.length - 1) {
            // finished — show participant/result
            const res = mapping[name] !== undefined ? mapping[name] : '(未割当)';
            resultDisplay.innerHTML = `<p><b>参加者：</b> ${escapeHtml(name)}</p><p><b>結果：</b> ${escapeHtml(res)}</p>`;
            return;
          }
          ctx.beginPath();
          ctx.moveTo(path[idx][0], path[idx][1]);
          ctx.lineTo(path[idx + 1][0], path[idx + 1][1]);
          ctx.stroke();
          idx++;
          // use setTimeout to keep previous cadence; token check will stop if needed
          setTimeout(step, 80);
        }

        step();
      }
    }

    // small helper to escape HTML in displayed text
    function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    // startup: detect hash and start appropriate mode
    window.onload = () => {
      const hash = location.hash;
      if (hash && (hash.startsWith('#data=') || hash.startsWith('#cfg='))) {
        try {
          const encoded = hash.replace(/^#(data|cfg)=/, '');
          const config = safeBase64Decode(decodeURIComponent(encoded));
          startAmidakuji(config);
        } catch (e) {
          alert('データの読み込みに失敗しました。設定モードに戻ります。');
          initAdminMode();
        }
      } else {
        initAdminMode();
      }
    };
  </script>
</body>
</html>

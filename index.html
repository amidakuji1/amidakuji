<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>あみだくじ</title>
  <style>
    body {
      font-family: "Noto Sans JP", sans-serif;
      text-align: center;
      background-color: #f5f5f5;
      margin: 0;
      padding: 20px;
    }
    #amidakuji-container {
      display: inline-block;
      position: relative;
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }
    svg {
      border: 1px solid #ccc;
      background: white;
    }
    button {
      margin: 8px;
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      background-color: #007bff;
      color: white;
      font-weight: bold;
      cursor: pointer;
    }
    button:hover {
      background-color: #0056b3;
    }
    .label {
      font-size: 16px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h2>あみだくじ</h2>
  <div id="amidakuji-container">
    <svg id="amidakuji" width="400" height="400"></svg>
  </div>
  <div id="buttons"></div>

  <script>
    const participants = ["小泉", "久郷", "吉田"];
    const results = ["1位", "2位", "3位"];
    const svg = document.getElementById("amidakuji");
    const lineCount = participants.length;
    const width = svg.getAttribute("width");
    const height = svg.getAttribute("height");
    const stepY = height / 6;

    // ラインの座標
    const positions = Array.from({ length: lineCount }, (_, i) => (i + 1) * (width / (lineCount + 1)));

    // 上部ラベル（参加者）
    participants.forEach((name, i) => {
      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("x", positions[i]);
      text.setAttribute("y", 20);
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("class", "label");
      text.textContent = name;
      svg.appendChild(text);
    });

    // 下部ラベル（結果）
    results.forEach((res, i) => {
      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("x", positions[i]);
      text.setAttribute("y", height - 10);
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("class", "label");
      text.textContent = res;
      svg.appendChild(text);
    });

    // 縦線描画
    positions.forEach(x => {
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", x);
      line.setAttribute("y1", 40);
      line.setAttribute("x2", x);
      line.setAttribute("y2", height - 40);
      line.setAttribute("stroke", "black");
      svg.appendChild(line);
    });

    // 横線生成
    const horizontalLines = [];
    for (let y = 80; y < height - 80; y += stepY) {
      const i = Math.floor(Math.random() * (lineCount - 1));
      horizontalLines.push({ x1: positions[i], x2: positions[i + 1], y });
    }

    horizontalLines.forEach(({ x1, x2, y }) => {
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", x1);
      line.setAttribute("y1", y);
      line.setAttribute("x2", x2);
      line.setAttribute("y2", y);
      line.setAttribute("stroke", "black");
      svg.appendChild(line);
    });

    // 結果アニメーション
    function trace(startIndex) {
      // 前の赤線削除
      const oldPath = svg.querySelector(".trace");
      if (oldPath) oldPath.remove();

      let x = positions[startIndex];
      let y = 40;
      let pathData = `M${x},${y}`;

      for (let { x1, x2, y: hy } of horizontalLines) {
        if (Math.abs(hy - y) < stepY / 2) continue;
        if (x === x1 && hy > y) { pathData += ` L${x},${hy} L${x2},${hy}`; x = x2; y = hy; }
        else if (x === x2 && hy > y) { pathData += ` L${x},${hy} L${x1},${hy}`; x = x1; y = hy; }
      }
      pathData += ` L${x},${height - 40}`;

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", pathData);
      path.setAttribute("fill", "none");
      path.setAttribute("stroke", "red");
      path.setAttribute("stroke-width", "2");
      path.setAttribute("class", "trace");
      path.style.strokeDasharray = "1000";
      path.style.strokeDashoffset = "1000";
      path.style.transition = "stroke-dashoffset 2s linear";
      svg.appendChild(path);

      setTimeout(() => {
        path.style.strokeDashoffset = "0";
      }, 10);
    }

    // ボタン生成
    participants.forEach((name, i) => {
      const btn = document.createElement("button");
      btn.textContent = name;
      btn.onclick = () => trace(i);
      document.getElementById("buttons").appendChild(btn);
    });
  </script>
</body>
</html>
